type Query {
  """The active Channel"""
  activeChannel: Channel!

  """The active Customer"""
  activeCustomer: Customer

  """
  The active Order. Will be `null` until an Order is created via `addItemToOrder`. Once an Order reaches the
  state of `PaymentAuthorized` or `PaymentSettled`, then that Order is no longer considered "active" and this
  query will once again return `null`.
  """
  activeOrder: Order

  """An array of supported Countries"""
  availableCountries: [Country!]!

  """A list of Collections available to the shop"""
  collections(options: CollectionListOptions): CollectionList!

  """
  Returns a Collection either by its id or slug. If neither 'id' nor 'slug' is specified, an error will result.
  """
  collection(id: ID, slug: String): Collection

  """
  Returns a list of eligible shipping methods based on the current active Order
  """
  eligibleShippingMethods: [ShippingMethodQuote!]!

  """
  Returns a list of payment methods and their eligibility based on the current active Order
  """
  eligiblePaymentMethods: [PaymentMethodQuote!]!

  """A list of Facets available to the shop"""
  facets(options: FacetListOptions): FacetList!

  """Returns a Facet by its id"""
  facet(id: ID!): Facet

  """Returns information about the current authenticated User"""
  me: CurrentUser

  """
  Returns the possible next states that the activeOrder can transition to
  """
  nextOrderStates: [String!]!

  """
  Returns an Order based on the id. Note that in the Shop API, only orders belonging to the
  currently-authenticated User may be queried.
  """
  order(id: ID!): Order

  """
  Returns an Order based on the order `code`. For guest Orders (i.e. Orders placed by non-authenticated Customers)
  this query will only return the Order within 2 hours of the Order being placed. This allows an Order confirmation
  screen to be shown immediately after completion of a guest checkout, yet prevents security risks of allowing
  general anonymous access to Order data.
  """
  orderByCode(code: String!): Order

  """
  Get a Product either by id or slug. If neither 'id' nor 'slug' is specified, an error will result.
  """
  product(id: ID, slug: String): Product

  """Get a list of Products"""
  products(options: ProductListOptions): ProductList!

  """Search Products based on the criteria set by the `SearchInput`"""
  search(input: SearchInput!): SearchResponse!

  """Get active payment methods"""
  activePaymentMethods: [PublicPaymentMethod]!

  """Get active shipping methods"""
  activeShippingMethods: [PublicShippingMethod]!
}

type Mutation {
  """
  Adds an item to the Order. If custom fields are defined on the OrderLine entity, a third argument 'customFields' will be available.
  """
  addItemToOrder(productVariantId: ID!, quantity: Int!): UpdateOrderItemsResult!

  """Remove an OrderLine from the Order"""
  removeOrderLine(orderLineId: ID!): RemoveOrderItemsResult!

  """Remove all OrderLine from the Order"""
  removeAllOrderLines: RemoveOrderItemsResult!

  """
  Adjusts an OrderLine. If custom fields are defined on the OrderLine entity, a third argument 'customFields' of type `OrderLineCustomFieldsInput` will be available.
  """
  adjustOrderLine(orderLineId: ID!, quantity: Int!): UpdateOrderItemsResult!

  """Applies the given coupon code to the active Order"""
  applyCouponCode(couponCode: String!): ApplyCouponCodeResult!

  """Removes the given coupon code from the active Order"""
  removeCouponCode(couponCode: String!): Order

  """
  Transitions an Order to a new state. Valid next states can be found by querying `nextOrderStates`
  """
  transitionOrderToState(state: String!): TransitionOrderToStateResult

  """Sets the shipping address for the active Order"""
  setOrderShippingAddress(input: CreateAddressInput!): ActiveOrderResult!

  """Sets the billing address for the active Order"""
  setOrderBillingAddress(input: CreateAddressInput!): ActiveOrderResult!

  """
  Unsets the shipping address for the active Order. Available since version 3.1.0
  """
  unsetOrderShippingAddress: ActiveOrderResult!

  """
  Unsets the billing address for the active Order. Available since version 3.1.0
  """
  unsetOrderBillingAddress: ActiveOrderResult!

  """Allows any custom fields to be set for the active Order"""
  setOrderCustomFields(input: UpdateOrderInput!): ActiveOrderResult!

  """
  Sets the shipping method by id, which can be obtained with the `eligibleShippingMethods` query.
  An Order can have multiple shipping methods, in which case you can pass an array of ids. In this case,
  you should configure a custom ShippingLineAssignmentStrategy in order to know which OrderLines each
  shipping method will apply to.
  """
  setOrderShippingMethod(shippingMethodId: [ID!]!): SetOrderShippingMethodResult!

  """Add a Payment to the Order"""
  addPaymentToOrder(input: PaymentInput!): AddPaymentToOrderResult!

  """
  Set the Customer for the Order. Required only if the Customer is not currently logged in
  """
  setCustomerForOrder(input: CreateCustomerInput!): SetCustomerForOrderResult!

  """
  Authenticates the user using the native authentication strategy. This mutation is an alias for authenticate({ native: { ... }})
  
  The `rememberMe` option applies when using cookie-based sessions, and if `true` it will set the maxAge of the session cookie
  to 1 year.
  """
  login(username: String!, password: String!, rememberMe: Boolean): NativeAuthenticationResult!

  """Authenticates the user using a named authentication strategy"""
  authenticate(input: AuthenticationInput!, rememberMe: Boolean): AuthenticationResult!

  """End the current authenticated session"""
  logout: Success!

  """
  Register a Customer account with the given credentials. There are three possible registration flows:
  
  _If `authOptions.requireVerification` is set to `true`:_
  
  1. **The Customer is registered _with_ a password**. A verificationToken will be created (and typically emailed to the Customer). That
     verificationToken would then be passed to the `verifyCustomerAccount` mutation _without_ a password. The Customer is then
     verified and authenticated in one step.
  2. **The Customer is registered _without_ a password**. A verificationToken will be created (and typically emailed to the Customer). That
     verificationToken would then be passed to the `verifyCustomerAccount` mutation _with_ the chosen password of the Customer. The Customer is then
     verified and authenticated in one step.
  
  _If `authOptions.requireVerification` is set to `false`:_
  
  3. The Customer _must_ be registered _with_ a password. No further action is needed - the Customer is able to authenticate immediately.
  """
  registerCustomerAccount(input: RegisterCustomerInput!): RegisterCustomerAccountResult!

  """
  Regenerate and send a verification token for a new Customer registration. Only applicable if `authOptions.requireVerification` is set to true.
  """
  refreshCustomerVerification(emailAddress: String!): RefreshCustomerVerificationResult!

  """Update an existing Customer"""
  updateCustomer(input: UpdateCustomerInput!): Customer!

  """Create a new Customer Address"""
  createCustomerAddress(input: CreateAddressInput!): Address!

  """Update an existing Address"""
  updateCustomerAddress(input: UpdateAddressInput!): Address!

  """Delete an existing Address"""
  deleteCustomerAddress(id: ID!): Success!

  """
  Verify a Customer email address with the token sent to that address. Only applicable if `authOptions.requireVerification` is set to true.
  
  If the Customer was not registered with a password in the `registerCustomerAccount` mutation, the password _must_ be
  provided here.
  """
  verifyCustomerAccount(token: String!, password: String): VerifyCustomerAccountResult!

  """Update the password of the active Customer"""
  updateCustomerPassword(currentPassword: String!, newPassword: String!): UpdateCustomerPasswordResult!

  """
  Request to update the emailAddress of the active Customer. If `authOptions.requireVerification` is enabled
  (as is the default), then the `identifierChangeToken` will be assigned to the current User and
  a IdentifierChangeRequestEvent will be raised. This can then be used e.g. by the EmailPlugin to email
  that verification token to the Customer, which is then used to verify the change of email address.
  """
  requestUpdateCustomerEmailAddress(password: String!, newEmailAddress: String!): RequestUpdateCustomerEmailAddressResult!

  """
  Confirm the update of the emailAddress with the provided token, which has been generated by the
  `requestUpdateCustomerEmailAddress` mutation.
  """
  updateCustomerEmailAddress(token: String!): UpdateCustomerEmailAddressResult!

  """Requests a password reset email to be sent"""
  requestPasswordReset(emailAddress: String!): RequestPasswordResetResult

  """Resets a Customer's password based on the provided token"""
  resetPassword(token: String!, password: String!): ResetPasswordResult!
}

type Address implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  fullName: String
  company: String
  streetLine1: String!
  streetLine2: String
  city: String
  province: String
  postalCode: String
  country: Country!
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: AddressCustomFields
}

type Asset implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  type: AssetType!
  fileSize: Int!
  mimeType: String!
  width: Int!
  height: Int!
  source: String!
  preview: String!
  focalPoint: Coordinate
  tags: [Tag!]!
  customFields: JSON
}

type Coordinate {
  x: Float!
  y: Float!
}

type AssetList implements PaginatedList {
  items: [Asset!]!
  totalItems: Int!
}

enum AssetType {
  IMAGE
  VIDEO
  BINARY
}

type CurrentUser {
  id: ID!
  identifier: String!
  channels: [CurrentUserChannel!]!
}

type CurrentUserChannel {
  id: ID!
  token: String!
  code: String!
  permissions: [Permission!]!
}

type Channel implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  token: String!
  defaultTaxZone: Zone
  defaultShippingZone: Zone
  defaultLanguageCode: LanguageCode!
  availableLanguageCodes: [LanguageCode!]
  currencyCode: CurrencyCode! @deprecated(reason: "Use defaultCurrencyCode instead")
  defaultCurrencyCode: CurrencyCode!
  availableCurrencyCodes: [CurrencyCode!]!

  """Not yet used - will be implemented in a future release."""
  trackInventory: Boolean

  """Not yet used - will be implemented in a future release."""
  outOfStockThreshold: Int
  pricesIncludeTax: Boolean!
  seller: Seller
  customFields: JSON
}

type Collection implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode
  name: String!
  slug: String!
  breadcrumbs: [CollectionBreadcrumb!]!
  position: Int!
  description: String!
  featuredAsset: Asset
  assets: [Asset!]!
  parent: Collection
  parentId: ID!
  children: [Collection!]
  filters: [ConfigurableOperation!]!
  translations: [CollectionTranslation!]!
  productVariants(options: ProductVariantListOptions): ProductVariantList!
  customFields: JSON
}

type CollectionBreadcrumb {
  id: ID!
  name: String!
  slug: String!
}

type CollectionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
}

type CollectionList implements PaginatedList {
  items: [Collection!]!
  totalItems: Int!
}

enum GlobalFlag {
  TRUE
  FALSE
  INHERIT
}

enum AdjustmentType {
  PROMOTION
  DISTRIBUTED_ORDER_PROMOTION
  OTHER
}

enum DeletionResult {
  """The entity was successfully deleted"""
  DELETED

  """Deletion did not take place, reason given in message"""
  NOT_DELETED
}

"""
@description
Permissions for administrators and customers. Used to control access to
GraphQL resolvers via the {@link Allow} decorator.

## Understanding Permission.Owner

`Permission.Owner` is a special permission which is used in some Vendure resolvers to indicate that that resolver should only
be accessible to the "owner" of that resource.

For example, the Shop API `activeCustomer` query resolver should only return the Customer object for the "owner" of that Customer, i.e.
based on the activeUserId of the current session. As a result, the resolver code looks like this:

@example
```TypeScript
\@Query()
\@Allow(Permission.Owner)
async activeCustomer(\@Ctx() ctx: RequestContext): Promise<Customer | undefined> {
  const userId = ctx.activeUserId;
  if (userId) {
    return this.customerService.findOneByUserId(ctx, userId);
  }
}
```

Here we can see that the "ownership" must be enforced by custom logic inside the resolver. Since "ownership" cannot be defined generally
nor statically encoded at build-time, any resolvers using `Permission.Owner` **must** include logic to enforce that only the owner
of the resource has access. If not, then it is the equivalent of using `Permission.Public`.


@docsCategory common
"""
enum Permission {
  """Authenticated means simply that the user is logged in"""
  Authenticated

  """SuperAdmin has unrestricted access to all operations"""
  SuperAdmin

  """Owner means the user owns this entity, e.g. a Customer's own Order"""
  Owner

  """Public means any unauthenticated user may perform the operation"""
  Public

  """Grants permission to update GlobalSettings"""
  UpdateGlobalSettings

  """Grants permission to create Products, Facets, Assets, Collections"""
  CreateCatalog

  """Grants permission to read Products, Facets, Assets, Collections"""
  ReadCatalog

  """Grants permission to update Products, Facets, Assets, Collections"""
  UpdateCatalog

  """Grants permission to delete Products, Facets, Assets, Collections"""
  DeleteCatalog

  """
  Grants permission to create PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings
  """
  CreateSettings

  """
  Grants permission to read PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings
  """
  ReadSettings

  """
  Grants permission to update PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings
  """
  UpdateSettings

  """
  Grants permission to delete PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings
  """
  DeleteSettings

  """Grants permission to create Administrator"""
  CreateAdministrator

  """Grants permission to read Administrator"""
  ReadAdministrator

  """Grants permission to update Administrator"""
  UpdateAdministrator

  """Grants permission to delete Administrator"""
  DeleteAdministrator

  """Grants permission to create Asset"""
  CreateAsset

  """Grants permission to read Asset"""
  ReadAsset

  """Grants permission to update Asset"""
  UpdateAsset

  """Grants permission to delete Asset"""
  DeleteAsset

  """Grants permission to create Channel"""
  CreateChannel

  """Grants permission to read Channel"""
  ReadChannel

  """Grants permission to update Channel"""
  UpdateChannel

  """Grants permission to delete Channel"""
  DeleteChannel

  """Grants permission to create Collection"""
  CreateCollection

  """Grants permission to read Collection"""
  ReadCollection

  """Grants permission to update Collection"""
  UpdateCollection

  """Grants permission to delete Collection"""
  DeleteCollection

  """Grants permission to create Country"""
  CreateCountry

  """Grants permission to read Country"""
  ReadCountry

  """Grants permission to update Country"""
  UpdateCountry

  """Grants permission to delete Country"""
  DeleteCountry

  """Grants permission to create Customer"""
  CreateCustomer

  """Grants permission to read Customer"""
  ReadCustomer

  """Grants permission to update Customer"""
  UpdateCustomer

  """Grants permission to delete Customer"""
  DeleteCustomer

  """Grants permission to create CustomerGroup"""
  CreateCustomerGroup

  """Grants permission to read CustomerGroup"""
  ReadCustomerGroup

  """Grants permission to update CustomerGroup"""
  UpdateCustomerGroup

  """Grants permission to delete CustomerGroup"""
  DeleteCustomerGroup

  """Grants permission to create Facet"""
  CreateFacet

  """Grants permission to read Facet"""
  ReadFacet

  """Grants permission to update Facet"""
  UpdateFacet

  """Grants permission to delete Facet"""
  DeleteFacet

  """Grants permission to create Order"""
  CreateOrder

  """Grants permission to read Order"""
  ReadOrder

  """Grants permission to update Order"""
  UpdateOrder

  """Grants permission to delete Order"""
  DeleteOrder

  """Grants permission to create PaymentMethod"""
  CreatePaymentMethod

  """Grants permission to read PaymentMethod"""
  ReadPaymentMethod

  """Grants permission to update PaymentMethod"""
  UpdatePaymentMethod

  """Grants permission to delete PaymentMethod"""
  DeletePaymentMethod

  """Grants permission to create Product"""
  CreateProduct

  """Grants permission to read Product"""
  ReadProduct

  """Grants permission to update Product"""
  UpdateProduct

  """Grants permission to delete Product"""
  DeleteProduct

  """Grants permission to create Promotion"""
  CreatePromotion

  """Grants permission to read Promotion"""
  ReadPromotion

  """Grants permission to update Promotion"""
  UpdatePromotion

  """Grants permission to delete Promotion"""
  DeletePromotion

  """Grants permission to create ShippingMethod"""
  CreateShippingMethod

  """Grants permission to read ShippingMethod"""
  ReadShippingMethod

  """Grants permission to update ShippingMethod"""
  UpdateShippingMethod

  """Grants permission to delete ShippingMethod"""
  DeleteShippingMethod

  """Grants permission to create Tag"""
  CreateTag

  """Grants permission to read Tag"""
  ReadTag

  """Grants permission to update Tag"""
  UpdateTag

  """Grants permission to delete Tag"""
  DeleteTag

  """Grants permission to create TaxCategory"""
  CreateTaxCategory

  """Grants permission to read TaxCategory"""
  ReadTaxCategory

  """Grants permission to update TaxCategory"""
  UpdateTaxCategory

  """Grants permission to delete TaxCategory"""
  DeleteTaxCategory

  """Grants permission to create TaxRate"""
  CreateTaxRate

  """Grants permission to read TaxRate"""
  ReadTaxRate

  """Grants permission to update TaxRate"""
  UpdateTaxRate

  """Grants permission to delete TaxRate"""
  DeleteTaxRate

  """Grants permission to create Seller"""
  CreateSeller

  """Grants permission to read Seller"""
  ReadSeller

  """Grants permission to update Seller"""
  UpdateSeller

  """Grants permission to delete Seller"""
  DeleteSeller

  """Grants permission to create StockLocation"""
  CreateStockLocation

  """Grants permission to read StockLocation"""
  ReadStockLocation

  """Grants permission to update StockLocation"""
  UpdateStockLocation

  """Grants permission to delete StockLocation"""
  DeleteStockLocation

  """Grants permission to create System"""
  CreateSystem

  """Grants permission to read System"""
  ReadSystem

  """Grants permission to update System"""
  UpdateSystem

  """Grants permission to delete System"""
  DeleteSystem

  """Grants permission to create Zone"""
  CreateZone

  """Grants permission to read Zone"""
  ReadZone

  """Grants permission to update Zone"""
  UpdateZone

  """Grants permission to delete Zone"""
  DeleteZone
}

enum SortOrder {
  ASC
  DESC
}

enum ErrorCode {
  UNKNOWN_ERROR
  NATIVE_AUTH_STRATEGY_ERROR
  INVALID_CREDENTIALS_ERROR
  ORDER_STATE_TRANSITION_ERROR
  EMAIL_ADDRESS_CONFLICT_ERROR
  GUEST_CHECKOUT_ERROR
  ORDER_LIMIT_ERROR
  NEGATIVE_QUANTITY_ERROR
  INSUFFICIENT_STOCK_ERROR
  COUPON_CODE_INVALID_ERROR
  COUPON_CODE_EXPIRED_ERROR
  COUPON_CODE_LIMIT_ERROR
  ORDER_MODIFICATION_ERROR
  INELIGIBLE_SHIPPING_METHOD_ERROR
  NO_ACTIVE_ORDER_ERROR
  ORDER_INTERCEPTOR_ERROR
  ORDER_PAYMENT_STATE_ERROR
  INELIGIBLE_PAYMENT_METHOD_ERROR
  PAYMENT_FAILED_ERROR
  PAYMENT_DECLINED_ERROR
  ALREADY_LOGGED_IN_ERROR
  MISSING_PASSWORD_ERROR
  PASSWORD_VALIDATION_ERROR
  PASSWORD_ALREADY_SET_ERROR
  VERIFICATION_TOKEN_INVALID_ERROR
  VERIFICATION_TOKEN_EXPIRED_ERROR
  IDENTIFIER_CHANGE_TOKEN_INVALID_ERROR
  IDENTIFIER_CHANGE_TOKEN_EXPIRED_ERROR
  PASSWORD_RESET_TOKEN_INVALID_ERROR
  PASSWORD_RESET_TOKEN_EXPIRED_ERROR
  NOT_VERIFIED_ERROR
}

enum LogicalOperator {
  AND
  OR
}

"""
Returned when attempting an operation that relies on the NativeAuthStrategy, if that strategy is not configured.
"""
type NativeAuthStrategyError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""Returned if the user authentication credentials are not valid"""
type InvalidCredentialsError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  authenticationError: String!
}

"""Returned if there is an error in transitioning the Order state"""
type OrderStateTransitionError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  transitionError: String!
  fromState: String!
  toState: String!
}

"""
Returned when attempting to create a Customer with an email address already registered to an existing User.
"""
type EmailAddressConflictError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when attempting to set the Customer on a guest checkout when the configured GuestCheckoutStrategy does not allow it.
"""
type GuestCheckoutError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  errorDetail: String!
}

"""Returned when the maximum order size limit has been reached."""
type OrderLimitError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  maxItems: Int!
}

"""Returned when attempting to set a negative OrderLine quantity."""
type NegativeQuantityError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when attempting to add more items to the Order than are available
"""
type InsufficientStockError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  quantityAvailable: Int!
  order: Order!
}

"""Returned if the provided coupon code is invalid"""
type CouponCodeInvalidError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  couponCode: String!
}

"""Returned if the provided coupon code is invalid"""
type CouponCodeExpiredError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  couponCode: String!
}

"""Returned if the provided coupon code is invalid"""
type CouponCodeLimitError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  couponCode: String!
  limit: Int!
}

"""
Returned when attempting to modify the contents of an Order that is not in the `AddingItems` state.
"""
type OrderModificationError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when attempting to set a ShippingMethod for which the Order is not eligible
"""
type IneligibleShippingMethodError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when invoking a mutation which depends on there being an active Order on the
current session.
"""
type NoActiveOrderError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when an order operation is rejected by an OrderInterceptor method.
"""
type OrderInterceptorError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  interceptorError: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""The `Upload` scalar type represents a file upload."""
scalar Upload

"""
The `Money` scalar type represents monetary values and supports signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
"""
scalar Money

interface PaginatedList {
  items: [Node!]!
  totalItems: Int!
}

interface Node {
  id: ID!
}

interface ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

type Adjustment {
  adjustmentSource: String!
  type: AdjustmentType!
  description: String!
  amount: Money!
  data: JSON
}

type TaxLine {
  description: String!
  taxRate: Float!
}

type ConfigArg {
  name: String!
  value: String!
}

type ConfigArgDefinition {
  name: String!
  type: String!
  list: Boolean!
  required: Boolean!
  defaultValue: JSON
  label: String
  description: String
  ui: JSON
}

type ConfigurableOperation {
  code: String!
  args: [ConfigArg!]!
}

type ConfigurableOperationDefinition {
  code: String!
  args: [ConfigArgDefinition!]!
  description: String!
}

type DeletionResponse {
  result: DeletionResult!
  message: String
}

input ConfigArgInput {
  name: String!

  """A JSON stringified representation of the actual value"""
  value: String!
}

input ConfigurableOperationInput {
  code: String!
  arguments: [ConfigArgInput!]!
}

"""Operators for filtering on a String field"""
input StringOperators {
  eq: String
  notEq: String
  contains: String
  notContains: String
  in: [String!]
  notIn: [String!]
  regex: String
  isNull: Boolean
}

"""Operators for filtering on an ID field"""
input IDOperators {
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  isNull: Boolean
}

"""Operators for filtering on a Boolean field"""
input BooleanOperators {
  eq: Boolean
  isNull: Boolean
}

input NumberRange {
  start: Float!
  end: Float!
}

"""Operators for filtering on a Int or Float field"""
input NumberOperators {
  eq: Float
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  between: NumberRange
  isNull: Boolean
}

input DateRange {
  start: DateTime!
  end: DateTime!
}

"""Operators for filtering on a DateTime field"""
input DateOperators {
  eq: DateTime
  before: DateTime
  after: DateTime
  between: DateRange
  isNull: Boolean
}

"""Operators for filtering on a list of String fields"""
input StringListOperators {
  inList: String!
}

"""Operators for filtering on a list of Number fields"""
input NumberListOperators {
  inList: Float!
}

"""Operators for filtering on a list of Boolean fields"""
input BooleanListOperators {
  inList: Boolean!
}

"""Operators for filtering on a list of ID fields"""
input IDListOperators {
  inList: ID!
}

"""Operators for filtering on a list of Date fields"""
input DateListOperators {
  inList: DateTime!
}

"""
Used to construct boolean expressions for filtering search results
by FacetValue ID. Examples:

* ID=1 OR ID=2: `{ facetValueFilters: [{ or: [1,2] }] }`
* ID=1 AND ID=2: `{ facetValueFilters: [{ and: 1 }, { and: 2 }] }`
* ID=1 AND (ID=2 OR ID=3): `{ facetValueFilters: [{ and: 1 }, { or: [2,3] }] }`
"""
input FacetValueFilterInput {
  and: ID
  or: [ID!]
}

input SearchInput {
  term: String
  facetValueFilters: [FacetValueFilterInput!]
  collectionId: ID
  collectionSlug: String
  groupByProduct: Boolean
  take: Int
  skip: Int
  sort: SearchResultSortParameter
  inStock: Boolean
}

input SearchResultSortParameter {
  name: SortOrder
  price: SortOrder
}

input CreateCustomerInput {
  title: String
  firstName: String!
  lastName: String!
  phoneNumber: String
  emailAddress: String!
  customFields: JSON
}

"""
Input used to create an Address.

The countryCode must correspond to a `code` property of a Country that has been defined in the
Vendure server. The `code` property is typically a 2-character ISO code such as "GB", "US", "DE" etc.
If an invalid code is passed, the mutation will fail.
"""
input CreateAddressInput {
  fullName: String
  company: String
  streetLine1: String!
  streetLine2: String
  city: String
  province: String
  postalCode: String
  countryCode: String!
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: CreateAddressCustomFieldsInput
}

"""
Input used to update an Address.

The countryCode must correspond to a `code` property of a Country that has been defined in the
Vendure server. The `code` property is typically a 2-character ISO code such as "GB", "US", "DE" etc.
If an invalid code is passed, the mutation will fail.
"""
input UpdateAddressInput {
  id: ID!
  fullName: String
  company: String
  streetLine1: String
  streetLine2: String
  city: String
  province: String
  postalCode: String
  countryCode: String
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: UpdateAddressCustomFieldsInput
}

"""
Indicates that an operation succeeded, where we do not want to return any more specific information.
"""
type Success {
  success: Boolean!
}

type ShippingMethodQuote {
  id: ID!
  price: Money!
  priceWithTax: Money!
  code: String!
  name: String!
  description: String!

  """
  Any optional metadata returned by the ShippingCalculator in the ShippingCalculationResult
  """
  metadata: JSON
  customFields: JSON
}

type PaymentMethodQuote {
  id: ID!
  code: String!
  name: String!
  description: String!
  isEligible: Boolean!
  eligibilityMessage: String
  customFields: JSON
}

union UpdateOrderItemsResult = Order | OrderModificationError | OrderLimitError | NegativeQuantityError | InsufficientStockError | OrderInterceptorError

union RemoveOrderItemsResult = Order | OrderModificationError | OrderInterceptorError

union SetOrderShippingMethodResult = Order | OrderModificationError | IneligibleShippingMethodError | NoActiveOrderError

union ApplyCouponCodeResult = Order | CouponCodeExpiredError | CouponCodeInvalidError | CouponCodeLimitError

"""
@description
ISO 4217 currency code

@docsCategory common
"""
enum CurrencyCode {
  """United Arab Emirates dirham"""
  AED

  """Afghan afghani"""
  AFN

  """Albanian lek"""
  ALL

  """Armenian dram"""
  AMD

  """Netherlands Antillean guilder"""
  ANG

  """Angolan kwanza"""
  AOA

  """Argentine peso"""
  ARS

  """Australian dollar"""
  AUD

  """Aruban florin"""
  AWG

  """Azerbaijani manat"""
  AZN

  """Bosnia and Herzegovina convertible mark"""
  BAM

  """Barbados dollar"""
  BBD

  """Bangladeshi taka"""
  BDT

  """Bulgarian lev"""
  BGN

  """Bahraini dinar"""
  BHD

  """Burundian franc"""
  BIF

  """Bermudian dollar"""
  BMD

  """Brunei dollar"""
  BND

  """Boliviano"""
  BOB

  """Brazilian real"""
  BRL

  """Bahamian dollar"""
  BSD

  """Bhutanese ngultrum"""
  BTN

  """Botswana pula"""
  BWP

  """Belarusian ruble"""
  BYN

  """Belize dollar"""
  BZD

  """Canadian dollar"""
  CAD

  """Congolese franc"""
  CDF

  """Swiss franc"""
  CHF

  """Chilean peso"""
  CLP

  """Renminbi (Chinese) yuan"""
  CNY

  """Colombian peso"""
  COP

  """Costa Rican colon"""
  CRC

  """Cuban convertible peso"""
  CUC

  """Cuban peso"""
  CUP

  """Cape Verde escudo"""
  CVE

  """Czech koruna"""
  CZK

  """Djiboutian franc"""
  DJF

  """Danish krone"""
  DKK

  """Dominican peso"""
  DOP

  """Algerian dinar"""
  DZD

  """Egyptian pound"""
  EGP

  """Eritrean nakfa"""
  ERN

  """Ethiopian birr"""
  ETB

  """Euro"""
  EUR

  """Fiji dollar"""
  FJD

  """Falkland Islands pound"""
  FKP

  """Pound sterling"""
  GBP

  """Georgian lari"""
  GEL

  """Ghanaian cedi"""
  GHS

  """Gibraltar pound"""
  GIP

  """Gambian dalasi"""
  GMD

  """Guinean franc"""
  GNF

  """Guatemalan quetzal"""
  GTQ

  """Guyanese dollar"""
  GYD

  """Hong Kong dollar"""
  HKD

  """Honduran lempira"""
  HNL

  """Croatian kuna"""
  HRK

  """Haitian gourde"""
  HTG

  """Hungarian forint"""
  HUF

  """Indonesian rupiah"""
  IDR

  """Israeli new shekel"""
  ILS

  """Indian rupee"""
  INR

  """Iraqi dinar"""
  IQD

  """Iranian rial"""
  IRR

  """Icelandic króna"""
  ISK

  """Jamaican dollar"""
  JMD

  """Jordanian dinar"""
  JOD

  """Japanese yen"""
  JPY

  """Kenyan shilling"""
  KES

  """Kyrgyzstani som"""
  KGS

  """Cambodian riel"""
  KHR

  """Comoro franc"""
  KMF

  """North Korean won"""
  KPW

  """South Korean won"""
  KRW

  """Kuwaiti dinar"""
  KWD

  """Cayman Islands dollar"""
  KYD

  """Kazakhstani tenge"""
  KZT

  """Lao kip"""
  LAK

  """Lebanese pound"""
  LBP

  """Sri Lankan rupee"""
  LKR

  """Liberian dollar"""
  LRD

  """Lesotho loti"""
  LSL

  """Libyan dinar"""
  LYD

  """Moroccan dirham"""
  MAD

  """Moldovan leu"""
  MDL

  """Malagasy ariary"""
  MGA

  """Macedonian denar"""
  MKD

  """Myanmar kyat"""
  MMK

  """Mongolian tögrög"""
  MNT

  """Macanese pataca"""
  MOP

  """Mauritanian ouguiya"""
  MRU

  """Mauritian rupee"""
  MUR

  """Maldivian rufiyaa"""
  MVR

  """Malawian kwacha"""
  MWK

  """Mexican peso"""
  MXN

  """Malaysian ringgit"""
  MYR

  """Mozambican metical"""
  MZN

  """Namibian dollar"""
  NAD

  """Nigerian naira"""
  NGN

  """Nicaraguan córdoba"""
  NIO

  """Norwegian krone"""
  NOK

  """Nepalese rupee"""
  NPR

  """New Zealand dollar"""
  NZD

  """Omani rial"""
  OMR

  """Panamanian balboa"""
  PAB

  """Peruvian sol"""
  PEN

  """Papua New Guinean kina"""
  PGK

  """Philippine peso"""
  PHP

  """Pakistani rupee"""
  PKR

  """Polish złoty"""
  PLN

  """Paraguayan guaraní"""
  PYG

  """Qatari riyal"""
  QAR

  """Romanian leu"""
  RON

  """Serbian dinar"""
  RSD

  """Russian ruble"""
  RUB

  """Rwandan franc"""
  RWF

  """Saudi riyal"""
  SAR

  """Solomon Islands dollar"""
  SBD

  """Seychelles rupee"""
  SCR

  """Sudanese pound"""
  SDG

  """Swedish krona/kronor"""
  SEK

  """Singapore dollar"""
  SGD

  """Saint Helena pound"""
  SHP

  """Sierra Leonean leone"""
  SLL

  """Somali shilling"""
  SOS

  """Surinamese dollar"""
  SRD

  """South Sudanese pound"""
  SSP

  """São Tomé and Príncipe dobra"""
  STN

  """Salvadoran colón"""
  SVC

  """Syrian pound"""
  SYP

  """Swazi lilangeni"""
  SZL

  """Thai baht"""
  THB

  """Tajikistani somoni"""
  TJS

  """Turkmenistan manat"""
  TMT

  """Tunisian dinar"""
  TND

  """Tongan paʻanga"""
  TOP

  """Turkish lira"""
  TRY

  """Trinidad and Tobago dollar"""
  TTD

  """New Taiwan dollar"""
  TWD

  """Tanzanian shilling"""
  TZS

  """Ukrainian hryvnia"""
  UAH

  """Ugandan shilling"""
  UGX

  """United States dollar"""
  USD

  """Uruguayan peso"""
  UYU

  """Uzbekistan som"""
  UZS

  """Venezuelan bolívar soberano"""
  VES

  """Vietnamese đồng"""
  VND

  """Vanuatu vatu"""
  VUV

  """Samoan tala"""
  WST

  """CFA franc BEAC"""
  XAF

  """East Caribbean dollar"""
  XCD

  """CFA franc BCEAO"""
  XOF

  """CFP franc (franc Pacifique)"""
  XPF

  """Yemeni rial"""
  YER

  """South African rand"""
  ZAR

  """Zambian kwacha"""
  ZMW

  """Zimbabwean dollar"""
  ZWL
}

interface CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  ui: JSON
}

type StringCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  length: Int
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  pattern: String
  options: [StringFieldOption!]
  ui: JSON
}

type StringFieldOption {
  value: String!
  label: [LocalizedString!]
}

type LocaleStringCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  length: Int
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  pattern: String
  ui: JSON
}

type IntCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  min: Int
  max: Int
  step: Int
  ui: JSON
}

type FloatCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  min: Float
  max: Float
  step: Float
  ui: JSON
}

type BooleanCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  ui: JSON
}

"""
Expects the same validation formats as the `<input type="datetime-local">` HTML element.
See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local#Additional_attributes
"""
type DateTimeCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  min: String
  max: String
  step: Int
  ui: JSON
}

type RelationCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  entity: String!
  scalarFields: [String!]!
  ui: JSON
}

type TextCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  ui: JSON
}

type LocaleTextCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  ui: JSON
}

interface StructField {
  name: String!
  type: String!
  list: Boolean
  label: [LocalizedString!]
  description: [LocalizedString!]
  ui: JSON
}

type StringStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  length: Int
  pattern: String
  options: [StringFieldOption!]
  ui: JSON
}

type IntStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  min: Int
  max: Int
  step: Int
  ui: JSON
}

type FloatStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  min: Float
  max: Float
  step: Float
  ui: JSON
}

type BooleanStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  ui: JSON
}

"""
Expects the same validation formats as the `<input type="datetime-local">` HTML element.
See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local#Additional_attributes
"""
type DateTimeStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  min: String
  max: String
  step: Int
  ui: JSON
}

type TextStructFieldConfig implements StructField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  ui: JSON
}

union StructFieldConfig = StringStructFieldConfig | IntStructFieldConfig | FloatStructFieldConfig | BooleanStructFieldConfig | DateTimeStructFieldConfig | TextStructFieldConfig

type StructCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  fields: [StructFieldConfig!]!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  nullable: Boolean
  requiresPermission: [Permission!]
  ui: JSON
}

type LocalizedString {
  languageCode: LanguageCode!
  value: String!
}

union CustomFieldConfig = StringCustomFieldConfig | LocaleStringCustomFieldConfig | IntCustomFieldConfig | FloatCustomFieldConfig | BooleanCustomFieldConfig | DateTimeCustomFieldConfig | RelationCustomFieldConfig | TextCustomFieldConfig | LocaleTextCustomFieldConfig | StructCustomFieldConfig

type CustomerGroup implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  customers(options: CustomerListOptions): CustomerList!
  customFields: JSON
}

input CustomerListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: CustomerSortParameter

  """Allows the results to be filtered"""
  filter: CustomerFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

type Customer implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String
  firstName: String!
  lastName: String!
  phoneNumber: String
  emailAddress: String!
  addresses: [Address!]
  orders(options: OrderListOptions): OrderList!
  user: User
  customFields: JSON
}

type CustomerList implements PaginatedList {
  items: [Customer!]!
  totalItems: Int!
}

type FacetValue implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  facet: Facet!
  facetId: ID!
  name: String!
  code: String!
  translations: [FacetValueTranslation!]!
  customFields: JSON
}

type FacetValueTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type Facet implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  code: String!
  values: [FacetValue!]!

  """
  Returns a paginated, sortable, filterable list of the Facet's values. Added in v2.1.0.
  """
  valueList(options: FacetValueListOptions): FacetValueList!
  translations: [FacetTranslation!]!
  customFields: JSON
}

type FacetTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type FacetList implements PaginatedList {
  items: [Facet!]!
  totalItems: Int!
}

input FacetValueListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: FacetValueSortParameter

  """Allows the results to be filtered"""
  filter: FacetValueFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

type FacetValueList implements PaginatedList {
  items: [FacetValue!]!
  totalItems: Int!
}

type HistoryEntry implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: HistoryEntryType!
  data: JSON!
  customFields: JSON
}

enum HistoryEntryType {
  CUSTOMER_REGISTERED
  CUSTOMER_VERIFIED
  CUSTOMER_DETAIL_UPDATED
  CUSTOMER_ADDED_TO_GROUP
  CUSTOMER_REMOVED_FROM_GROUP
  CUSTOMER_ADDRESS_CREATED
  CUSTOMER_ADDRESS_UPDATED
  CUSTOMER_ADDRESS_DELETED
  CUSTOMER_PASSWORD_UPDATED
  CUSTOMER_PASSWORD_RESET_REQUESTED
  CUSTOMER_PASSWORD_RESET_VERIFIED
  CUSTOMER_EMAIL_UPDATE_REQUESTED
  CUSTOMER_EMAIL_UPDATE_VERIFIED
  CUSTOMER_NOTE
  ORDER_STATE_TRANSITION
  ORDER_PAYMENT_TRANSITION
  ORDER_FULFILLMENT
  ORDER_CANCELLATION
  ORDER_REFUND_TRANSITION
  ORDER_FULFILLMENT_TRANSITION
  ORDER_NOTE
  ORDER_COUPON_APPLIED
  ORDER_COUPON_REMOVED
  ORDER_MODIFIED
  ORDER_CUSTOMER_UPDATED
}

type HistoryEntryList implements PaginatedList {
  items: [HistoryEntry!]!
  totalItems: Int!
}

input HistoryEntryListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: HistoryEntrySortParameter

  """Allows the results to be filtered"""
  filter: HistoryEntryFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

"""
@description
Languages in the form of a ISO 639-1 language code with optional
region or script modifier (e.g. de_AT). The selection available is based
on the [Unicode CLDR summary list](https://unicode-org.github.io/cldr-staging/charts/37/summary/root.html)
and includes the major spoken languages of the world and any widely-used variants.

@docsCategory common
"""
enum LanguageCode {
  """Afrikaans"""
  af

  """Akan"""
  ak

  """Albanian"""
  sq

  """Amharic"""
  am

  """Arabic"""
  ar

  """Armenian"""
  hy

  """Assamese"""
  as

  """Azerbaijani"""
  az

  """Bambara"""
  bm

  """Bangla"""
  bn

  """Basque"""
  eu

  """Belarusian"""
  be

  """Bosnian"""
  bs

  """Breton"""
  br

  """Bulgarian"""
  bg

  """Burmese"""
  my

  """Catalan"""
  ca

  """Chechen"""
  ce

  """Chinese"""
  zh

  """Simplified Chinese"""
  zh_Hans

  """Traditional Chinese"""
  zh_Hant

  """Church Slavic"""
  cu

  """Cornish"""
  kw

  """Corsican"""
  co

  """Croatian"""
  hr

  """Czech"""
  cs

  """Danish"""
  da

  """Dutch"""
  nl

  """Flemish"""
  nl_BE

  """Dzongkha"""
  dz

  """English"""
  en

  """Australian English"""
  en_AU

  """Canadian English"""
  en_CA

  """British English"""
  en_GB

  """American English"""
  en_US

  """Esperanto"""
  eo

  """Estonian"""
  et

  """Ewe"""
  ee

  """Faroese"""
  fo

  """Finnish"""
  fi

  """French"""
  fr

  """Canadian French"""
  fr_CA

  """Swiss French"""
  fr_CH

  """Fulah"""
  ff

  """Galician"""
  gl

  """Ganda"""
  lg

  """Georgian"""
  ka

  """German"""
  de

  """Austrian German"""
  de_AT

  """Swiss High German"""
  de_CH

  """Greek"""
  el

  """Gujarati"""
  gu

  """Haitian Creole"""
  ht

  """Hausa"""
  ha

  """Hebrew"""
  he

  """Hindi"""
  hi

  """Hungarian"""
  hu

  """Icelandic"""
  is

  """Igbo"""
  ig

  """Indonesian"""
  id

  """Interlingua"""
  ia

  """Irish"""
  ga

  """Italian"""
  it

  """Japanese"""
  ja

  """Javanese"""
  jv

  """Kalaallisut"""
  kl

  """Kannada"""
  kn

  """Kashmiri"""
  ks

  """Kazakh"""
  kk

  """Khmer"""
  km

  """Kikuyu"""
  ki

  """Kinyarwanda"""
  rw

  """Korean"""
  ko

  """Kurdish"""
  ku

  """Kyrgyz"""
  ky

  """Lao"""
  lo

  """Latin"""
  la

  """Latvian"""
  lv

  """Lingala"""
  ln

  """Lithuanian"""
  lt

  """Luba-Katanga"""
  lu

  """Luxembourgish"""
  lb

  """Macedonian"""
  mk

  """Malagasy"""
  mg

  """Malay"""
  ms

  """Malayalam"""
  ml

  """Maltese"""
  mt

  """Manx"""
  gv

  """Maori"""
  mi

  """Marathi"""
  mr

  """Mongolian"""
  mn

  """Nepali"""
  ne

  """North Ndebele"""
  nd

  """Northern Sami"""
  se

  """Norwegian Bokmål"""
  nb

  """Norwegian Nynorsk"""
  nn

  """Nyanja"""
  ny

  """Odia"""
  or

  """Oromo"""
  om

  """Ossetic"""
  os

  """Pashto"""
  ps

  """Persian"""
  fa

  """Dari"""
  fa_AF

  """Polish"""
  pl

  """Portuguese"""
  pt

  """Brazilian Portuguese"""
  pt_BR

  """European Portuguese"""
  pt_PT

  """Punjabi"""
  pa

  """Quechua"""
  qu

  """Romanian"""
  ro

  """Moldavian"""
  ro_MD

  """Romansh"""
  rm

  """Rundi"""
  rn

  """Russian"""
  ru

  """Samoan"""
  sm

  """Sango"""
  sg

  """Sanskrit"""
  sa

  """Scottish Gaelic"""
  gd

  """Serbian"""
  sr

  """Shona"""
  sn

  """Sichuan Yi"""
  ii

  """Sindhi"""
  sd

  """Sinhala"""
  si

  """Slovak"""
  sk

  """Slovenian"""
  sl

  """Somali"""
  so

  """Southern Sotho"""
  st

  """Spanish"""
  es

  """European Spanish"""
  es_ES

  """Mexican Spanish"""
  es_MX

  """Sundanese"""
  su

  """Swahili"""
  sw

  """Congo Swahili"""
  sw_CD

  """Swedish"""
  sv

  """Tajik"""
  tg

  """Tamil"""
  ta

  """Tatar"""
  tt

  """Telugu"""
  te

  """Thai"""
  th

  """Tibetan"""
  bo

  """Tigrinya"""
  ti

  """Tongan"""
  to

  """Turkish"""
  tr

  """Turkmen"""
  tk

  """Ukrainian"""
  uk

  """Urdu"""
  ur

  """Uyghur"""
  ug

  """Uzbek"""
  uz

  """Vietnamese"""
  vi

  """Volapük"""
  vo

  """Welsh"""
  cy

  """Western Frisian"""
  fy

  """Wolof"""
  wo

  """Xhosa"""
  xh

  """Yiddish"""
  yi

  """Yoruba"""
  yo

  """Zulu"""
  zu
}

enum OrderType {
  Regular
  Seller
  Aggregate
}

type Order implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: OrderType!

  """
  The date & time that the Order was placed, i.e. the Customer
  completed the checkout and the Order is no longer "active"
  """
  orderPlacedAt: DateTime

  """A unique code for the Order"""
  code: String!
  state: String!

  """
  An order is active as long as the payment process has not been completed
  """
  active: Boolean!
  customer: Customer
  shippingAddress: OrderAddress
  billingAddress: OrderAddress
  lines: [OrderLine!]!

  """
  Surcharges are arbitrary modifications to the Order total which are neither
  ProductVariants nor discounts resulting from applied Promotions. For example,
  one-off discounts based on customer interaction, or surcharges based on payment
  methods.
  """
  surcharges: [Surcharge!]!
  discounts: [Discount!]!

  """An array of all coupon codes applied to the Order"""
  couponCodes: [String!]!

  """
  Promotions applied to the order. Only gets populated after the payment process has completed.
  """
  promotions: [Promotion!]!
  payments: [Payment!]
  fulfillments: [Fulfillment!]
  totalQuantity: Int!

  """
  The subTotal is the total of all OrderLines in the Order. This figure also includes any Order-level
  discounts which have been prorated (proportionally distributed) amongst the items of each OrderLine.
  To get a total of all OrderLines which does not account for prorated discounts, use the
  sum of `OrderLine.discountedLinePrice` values.
  """
  subTotal: Money!

  """Same as subTotal, but inclusive of tax"""
  subTotalWithTax: Money!
  currencyCode: CurrencyCode!
  shippingLines: [ShippingLine!]!
  shipping: Money!
  shippingWithTax: Money!

  """Equal to subTotal plus shipping"""
  total: Money!

  """
  The final payable amount. Equal to subTotalWithTax plus shippingWithTax
  """
  totalWithTax: Money!

  """A summary of the taxes being applied to this Order"""
  taxSummary: [OrderTaxSummary!]!
  history(options: HistoryEntryListOptions): HistoryEntryList!
  customFields: JSON
}

"""
A summary of the taxes being applied to this order, grouped
by taxRate.
"""
type OrderTaxSummary {
  """A description of this tax"""
  description: String!

  """The taxRate as a percentage"""
  taxRate: Float!

  """The total net price of OrderLines to which this taxRate applies"""
  taxBase: Money!

  """The total tax being applied to the Order at this taxRate"""
  taxTotal: Money!
}

type OrderAddress {
  fullName: String
  company: String
  streetLine1: String
  streetLine2: String
  city: String
  province: String
  postalCode: String
  country: String
  countryCode: String
  phoneNumber: String
  customFields: AddressCustomFields
}

type OrderList implements PaginatedList {
  items: [Order!]!
  totalItems: Int!
}

type ShippingLine {
  id: ID!
  shippingMethod: ShippingMethod!
  price: Money!
  priceWithTax: Money!
  discountedPrice: Money!
  discountedPriceWithTax: Money!
  discounts: [Discount!]!
  customFields: JSON
}

type Discount {
  adjustmentSource: String!
  type: AdjustmentType!
  description: String!
  amount: Money!
  amountWithTax: Money!
}

type OrderLine implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  featuredAsset: Asset

  """The price of a single unit, excluding tax and discounts"""
  unitPrice: Money!

  """The price of a single unit, including tax but excluding discounts"""
  unitPriceWithTax: Money!

  """
  Non-zero if the unitPrice has changed since it was initially added to Order
  """
  unitPriceChangeSinceAdded: Money!

  """
  Non-zero if the unitPriceWithTax has changed since it was initially added to Order
  """
  unitPriceWithTaxChangeSinceAdded: Money!

  """
  The price of a single unit including discounts, excluding tax.
  
  If Order-level discounts have been applied, this will not be the
  actual taxable unit price (see `proratedUnitPrice`), but is generally the
  correct price to display to customers to avoid confusion
  about the internal handling of distributed Order-level discounts.
  """
  discountedUnitPrice: Money!

  """The price of a single unit including discounts and tax"""
  discountedUnitPriceWithTax: Money!

  """
  The actual unit price, taking into account both item discounts _and_ prorated (proportionally-distributed)
  Order-level discounts. This value is the true economic value of the OrderItem, and is used in tax
  and refund calculations.
  """
  proratedUnitPrice: Money!

  """The proratedUnitPrice including tax"""
  proratedUnitPriceWithTax: Money!

  """The quantity of items purchased"""
  quantity: Int!

  """The quantity at the time the Order was placed"""
  orderPlacedQuantity: Int!
  taxRate: Float!

  """The total price of the line excluding tax and discounts."""
  linePrice: Money!

  """The total price of the line including tax but excluding discounts."""
  linePriceWithTax: Money!

  """The price of the line including discounts, excluding tax"""
  discountedLinePrice: Money!

  """The price of the line including discounts and tax"""
  discountedLinePriceWithTax: Money!

  """
  The actual line price, taking into account both item discounts _and_ prorated (proportionally-distributed)
  Order-level discounts. This value is the true economic value of the OrderLine, and is used in tax
  and refund calculations.
  """
  proratedLinePrice: Money!

  """The proratedLinePrice including tax"""
  proratedLinePriceWithTax: Money!

  """The total tax on this line"""
  lineTax: Money!
  discounts: [Discount!]!
  taxLines: [TaxLine!]!
  order: Order!
  fulfillmentLines: [FulfillmentLine!]
  customFields: JSON
}

type Payment implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  method: String!
  amount: Money!
  state: String!
  transactionId: String
  errorMessage: String
  refunds: [Refund!]!
  metadata: JSON
  customFields: JSON
}

type RefundLine {
  orderLine: OrderLine!
  orderLineId: ID!
  quantity: Int!
  refund: Refund!
  refundId: ID!
}

type Refund implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  items: Money!
  shipping: Money!
  adjustment: Money!
  total: Money!
  method: String
  state: String!
  transactionId: String
  reason: String
  lines: [RefundLine!]!
  paymentId: ID!
  metadata: JSON
  customFields: JSON
}

type FulfillmentLine {
  orderLine: OrderLine!
  orderLineId: ID!
  quantity: Int!
  fulfillment: Fulfillment!
  fulfillmentId: ID!
}

type Fulfillment implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lines: [FulfillmentLine!]!
  summary: [FulfillmentLine!]! @deprecated(reason: "Use the `lines` field instead")
  state: String!
  method: String!
  trackingCode: String
  customFields: JSON
}

type Surcharge implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  sku: String
  taxLines: [TaxLine!]!
  price: Money!
  priceWithTax: Money!
  taxRate: Float!
}

type PaymentMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  code: String!
  description: String!
  enabled: Boolean!
  checker: ConfigurableOperation
  handler: ConfigurableOperation!
  translations: [PaymentMethodTranslation!]!
  customFields: JSON
}

type PaymentMethodTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  description: String!
}

type ProductOptionGroup implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  options: [ProductOption!]!
  translations: [ProductOptionGroupTranslation!]!
  customFields: JSON
}

type ProductOptionGroupTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type ProductOption implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  groupId: ID!
  group: ProductOptionGroup!
  translations: [ProductOptionTranslation!]!
  customFields: JSON
}

type ProductOptionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type SearchReindexResponse {
  success: Boolean!
}

type SearchResponse {
  items: [SearchResult!]!
  totalItems: Int!
  facetValues: [FacetValueResult!]!
  collections: [CollectionResult!]!
}

"""
Which FacetValues are present in the products returned
by the search, and in what quantity.
"""
type FacetValueResult {
  facetValue: FacetValue!
  count: Int!
}

"""
Which Collections are present in the products returned
by the search, and in what quantity.
"""
type CollectionResult {
  collection: Collection!
  count: Int!
}

type SearchResultAsset {
  id: ID!
  preview: String!
  focalPoint: Coordinate
}

type SearchResult {
  sku: String!
  slug: String!
  productId: ID!
  productName: String!
  productAsset: SearchResultAsset
  productVariantId: ID!
  productVariantName: String!
  productVariantAsset: SearchResultAsset
  price: SearchResultPrice!
  priceWithTax: SearchResultPrice!
  currencyCode: CurrencyCode!
  description: String!
  facetIds: [ID!]!
  facetValueIds: [ID!]!

  """An array of ids of the Collections in which this result appears"""
  collectionIds: [ID!]!

  """
  A relevance score for the result. Differs between database implementations
  """
  score: Float!
  inStock: Boolean!
}

"""
The price of a search result product, either as a range or as a single price
"""
union SearchResultPrice = PriceRange | SinglePrice

"""The price value where the result has a single price"""
type SinglePrice {
  value: Money!
}

"""The price range where the result has more than one price"""
type PriceRange {
  min: Money!
  max: Money!
}

type Product implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
  enabled: Boolean!
  featuredAsset: Asset
  assets: [Asset!]!

  """Returns all ProductVariants"""
  variants: [ProductVariant!]!

  """Returns a paginated, sortable, filterable list of ProductVariants"""
  variantList(options: ProductVariantListOptions): ProductVariantList!
  optionGroups: [ProductOptionGroup!]!
  facetValues: [FacetValue!]!
  translations: [ProductTranslation!]!
  collections: [Collection!]!
  customFields: JSON
}

type ProductTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
}

type ProductList implements PaginatedList {
  items: [Product!]!
  totalItems: Int!
}

type ProductVariantList implements PaginatedList {
  items: [ProductVariant!]!
  totalItems: Int!
}

type ProductVariant implements Node {
  id: ID!
  product: Product!
  productId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  sku: String!
  name: String!
  featuredAsset: Asset
  assets: [Asset!]!
  price: Money!
  currencyCode: CurrencyCode!
  priceWithTax: Money!
  stockLevel: String!
  taxRateApplied: TaxRate!
  taxCategory: TaxCategory!
  options: [ProductOption!]!
  facetValues: [FacetValue!]!
  translations: [ProductVariantTranslation!]!
  customFields: JSON
}

type ProductVariantTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type Promotion implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  startsAt: DateTime
  endsAt: DateTime
  couponCode: String
  perCustomerUsageLimit: Int
  usageLimit: Int
  name: String!
  description: String!
  enabled: Boolean!
  conditions: [ConfigurableOperation!]!
  actions: [ConfigurableOperation!]!
  translations: [PromotionTranslation!]!
  customFields: JSON
}

type PromotionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  description: String!
}

type PromotionList implements PaginatedList {
  items: [Promotion!]!
  totalItems: Int!
}

interface Region implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  type: String!
  name: String!
  enabled: Boolean!
  parent: Region
  parentId: ID
  translations: [RegionTranslation!]!
}

type RegionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

"""
A Country of the world which your shop operates in.

The `code` field is typically a 2-character ISO code such as "GB", "US", "DE" etc. This code is used in certain inputs such as
`UpdateAddressInput` and `CreateAddressInput` to specify the country.
"""
type Country implements Region & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  type: String!
  name: String!
  enabled: Boolean!
  parent: Region
  parentId: ID
  translations: [RegionTranslation!]!
  customFields: JSON
}

type CountryList implements PaginatedList {
  items: [Country!]!
  totalItems: Int!
}

type Province implements Region & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  type: String!
  name: String!
  enabled: Boolean!
  parent: Region
  parentId: ID
  translations: [RegionTranslation!]!
  customFields: JSON
}

type ProvinceList implements PaginatedList {
  items: [Province!]!
  totalItems: Int!
}

type Role implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  description: String!
  permissions: [Permission!]!
  channels: [Channel!]!
}

type RoleList implements PaginatedList {
  items: [Role!]!
  totalItems: Int!
}

type Seller implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  customFields: JSON
}

type ShippingMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  description: String!
  fulfillmentHandlerCode: String!
  checker: ConfigurableOperation!
  calculator: ConfigurableOperation!
  translations: [ShippingMethodTranslation!]!
  customFields: JSON
}

type ShippingMethodTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  description: String!
}

type ShippingMethodList implements PaginatedList {
  items: [ShippingMethod!]!
  totalItems: Int!
}

type Tag implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  value: String!
}

type TagList implements PaginatedList {
  items: [Tag!]!
  totalItems: Int!
}

type TaxCategory implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  isDefault: Boolean!
  customFields: JSON
}

type TaxRate implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  enabled: Boolean!
  value: Float!
  category: TaxCategory!
  zone: Zone!
  customerGroup: CustomerGroup
  customFields: JSON
}

type TaxRateList implements PaginatedList {
  items: [TaxRate!]!
  totalItems: Int!
}

type User implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  identifier: String!
  verified: Boolean!
  roles: [Role!]!
  lastLogin: DateTime
  authenticationMethods: [AuthenticationMethod!]!
  customFields: JSON
}

type AuthenticationMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  strategy: String!
}

type Zone implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  members: [Region!]!
  customFields: JSON
}

"""
Returned when attempting to add a Payment to an Order that is not in the `ArrangingPayment` state.
"""
type OrderPaymentStateError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when attempting to add a Payment using a PaymentMethod for which the Order is not eligible.
"""
type IneligiblePaymentMethodError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  eligibilityCheckerMessage: String
}

"""Returned when a Payment fails due to an error."""
type PaymentFailedError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  paymentErrorMessage: String!
}

"""Returned when a Payment is declined by the payment provider."""
type PaymentDeclinedError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  paymentErrorMessage: String!
}

"""
Returned when attempting to set the Customer for an Order when already logged in.
"""
type AlreadyLoggedInError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when attempting to register or verify a customer account without a password, when one is required.
"""
type MissingPasswordError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned when attempting to register or verify a customer account where the given password fails password validation.
"""
type PasswordValidationError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  validationErrorMessage: String!
}

"""
Returned when attempting to verify a customer account with a password, when a password has already been set.
"""
type PasswordAlreadySetError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if the verification token (used to verify a Customer's email address) is either
invalid or does not match any expected tokens.
"""
type VerificationTokenInvalidError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if the verification token (used to verify a Customer's email address) is valid, but has
expired according to the `verificationTokenDuration` setting in the AuthOptions.
"""
type VerificationTokenExpiredError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if the token used to change a Customer's email address is either
invalid or does not match any expected tokens.
"""
type IdentifierChangeTokenInvalidError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if the token used to change a Customer's email address is valid, but has
expired according to the `verificationTokenDuration` setting in the AuthOptions.
"""
type IdentifierChangeTokenExpiredError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if the token used to reset a Customer's password is either
invalid or does not match any expected tokens.
"""
type PasswordResetTokenInvalidError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if the token used to reset a Customer's password is valid, but has
expired according to the `verificationTokenDuration` setting in the AuthOptions.
"""
type PasswordResetTokenExpiredError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

"""
Returned if `authOptions.requireVerification` is set to `true` (which is the default)
and an unverified user attempts to authenticate.
"""
type NotVerifiedError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

type PublicPaymentMethod {
  id: ID!
  code: String!
  name: String!
  description: String
  translations: [PaymentMethodTranslation!]!
}

type PublicShippingMethod {
  id: ID!
  code: String!
  name: String!
  description: String
  translations: [ShippingMethodTranslation!]!
}

input AuthenticationInput {
  native: NativeAuthInput
}

input RegisterCustomerInput {
  emailAddress: String!
  title: String
  firstName: String
  lastName: String
  phoneNumber: String
  password: String
}

input UpdateCustomerInput {
  title: String
  firstName: String
  lastName: String
  phoneNumber: String
  customFields: JSON
}

input UpdateOrderInput {
  customFields: JSON
}

"""Passed as input to the `addPaymentToOrder` mutation."""
input PaymentInput {
  """
  This field should correspond to the `code` property of a PaymentMethod.
  """
  method: String!

  """
  This field should contain arbitrary data passed to the specified PaymentMethodHandler's `createPayment()` method
  as the "metadata" argument. For example, it could contain an ID for the payment and other
  data generated by the payment provider.
  """
  metadata: JSON!
}

input CollectionListOptions {
  topLevelOnly: Boolean

  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: CollectionSortParameter

  """Allows the results to be filtered"""
  filter: CollectionFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input FacetListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: FacetSortParameter

  """Allows the results to be filtered"""
  filter: FacetFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input OrderListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: OrderSortParameter

  """Allows the results to be filtered"""
  filter: OrderFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input ProductListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: ProductSortParameter

  """Allows the results to be filtered"""
  filter: ProductFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

input ProductVariantListOptions {
  """Skips the first n results, for use in pagination"""
  skip: Int

  """Takes n results, for use in pagination"""
  take: Int

  """Specifies which properties to sort the results by"""
  sort: ProductVariantSortParameter

  """Allows the results to be filtered"""
  filter: ProductVariantFilterParameter

  """
  Specifies whether multiple top-level "filter" fields should be combined with a logical AND or OR operation. Defaults to AND.
  """
  filterOperator: LogicalOperator
}

union AddPaymentToOrderResult = Order | OrderPaymentStateError | IneligiblePaymentMethodError | PaymentFailedError | PaymentDeclinedError | OrderStateTransitionError | NoActiveOrderError

union TransitionOrderToStateResult = Order | OrderStateTransitionError

union SetCustomerForOrderResult = Order | AlreadyLoggedInError | EmailAddressConflictError | NoActiveOrderError | GuestCheckoutError

union RegisterCustomerAccountResult = Success | MissingPasswordError | PasswordValidationError | NativeAuthStrategyError

union RefreshCustomerVerificationResult = Success | NativeAuthStrategyError

union VerifyCustomerAccountResult = CurrentUser | VerificationTokenInvalidError | VerificationTokenExpiredError | MissingPasswordError | PasswordValidationError | PasswordAlreadySetError | NativeAuthStrategyError

union UpdateCustomerPasswordResult = Success | InvalidCredentialsError | PasswordValidationError | NativeAuthStrategyError

union RequestUpdateCustomerEmailAddressResult = Success | InvalidCredentialsError | EmailAddressConflictError | NativeAuthStrategyError

union UpdateCustomerEmailAddressResult = Success | IdentifierChangeTokenInvalidError | IdentifierChangeTokenExpiredError | NativeAuthStrategyError

union RequestPasswordResetResult = Success | NativeAuthStrategyError

union ResetPasswordResult = CurrentUser | PasswordResetTokenInvalidError | PasswordResetTokenExpiredError | PasswordValidationError | NativeAuthStrategyError | NotVerifiedError

union NativeAuthenticationResult = CurrentUser | InvalidCredentialsError | NotVerifiedError | NativeAuthStrategyError

union AuthenticationResult = CurrentUser | InvalidCredentialsError | NotVerifiedError

union ActiveOrderResult = Order | NoActiveOrderError

input ProductVariantFilterParameter {
  id: IDOperators
  productId: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  sku: StringOperators
  name: StringOperators
  price: NumberOperators
  currencyCode: StringOperators
  priceWithTax: NumberOperators
  stockLevel: StringOperators
  _and: [ProductVariantFilterParameter!]
  _or: [ProductVariantFilterParameter!]
}

input ProductVariantSortParameter {
  id: SortOrder
  productId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  sku: SortOrder
  name: SortOrder
  price: SortOrder
  priceWithTax: SortOrder
  stockLevel: SortOrder
}

input CustomerFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  title: StringOperators
  firstName: StringOperators
  lastName: StringOperators
  phoneNumber: StringOperators
  emailAddress: StringOperators
  _and: [CustomerFilterParameter!]
  _or: [CustomerFilterParameter!]
}

input CustomerSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  title: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  phoneNumber: SortOrder
  emailAddress: SortOrder
}

input OrderFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  type: StringOperators
  orderPlacedAt: DateOperators
  code: StringOperators
  state: StringOperators
  active: BooleanOperators
  totalQuantity: NumberOperators
  subTotal: NumberOperators
  subTotalWithTax: NumberOperators
  currencyCode: StringOperators
  shipping: NumberOperators
  shippingWithTax: NumberOperators
  total: NumberOperators
  totalWithTax: NumberOperators
  _and: [OrderFilterParameter!]
  _or: [OrderFilterParameter!]
}

input OrderSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  orderPlacedAt: SortOrder
  code: SortOrder
  state: SortOrder
  totalQuantity: SortOrder
  subTotal: SortOrder
  subTotalWithTax: SortOrder
  shipping: SortOrder
  shippingWithTax: SortOrder
  total: SortOrder
  totalWithTax: SortOrder
}

input FacetValueFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  facetId: IDOperators
  name: StringOperators
  code: StringOperators
  _and: [FacetValueFilterParameter!]
  _or: [FacetValueFilterParameter!]
}

input FacetValueSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  facetId: SortOrder
  name: SortOrder
  code: SortOrder
}

input HistoryEntryFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  type: StringOperators
  _and: [HistoryEntryFilterParameter!]
  _or: [HistoryEntryFilterParameter!]
}

input HistoryEntrySortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input CollectionFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  slug: StringOperators
  position: NumberOperators
  description: StringOperators
  parentId: IDOperators
  _and: [CollectionFilterParameter!]
  _or: [CollectionFilterParameter!]
}

input CollectionSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  slug: SortOrder
  position: SortOrder
  description: SortOrder
  parentId: SortOrder
}

input FacetFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  code: StringOperators
  _and: [FacetFilterParameter!]
  _or: [FacetFilterParameter!]
}

input FacetSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  code: SortOrder
}

input ProductFilterParameter {
  id: IDOperators
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  slug: StringOperators
  description: StringOperators
  enabled: BooleanOperators
  _and: [ProductFilterParameter!]
  _or: [ProductFilterParameter!]
}

input ProductSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  slug: SortOrder
  description: SortOrder
}

type AddressCustomFields {
  vatId: String
}

input CreateAddressCustomFieldsInput {
  vatId: String
}

input UpdateAddressCustomFieldsInput {
  vatId: String
}

input NativeAuthInput {
  username: String!
  password: String!
}